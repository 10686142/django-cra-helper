# django-cra-helper

## Introduction

**django-cra-helper** is the missing link between **Django** and **create-react-app**. By adding this to your Django project, you can almost effortlessly inject your React components into your Django templates and initialize component props via Django context variables.

> Note: For the purposes of this README, the abbreviation **CRA** will be used to refer to **create-react-app**.

## Installation

Use `pip` to install this package:

```sh
pip install django-cra-helper
```

## Setup & Configuration

Once **django-cra-helper** is installed, add `cra_helper` to your Django project's `INSTALLED_APPS`:

```python
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'cra_helper',
    'django.contrib.staticfiles',
]
```

> Note: you **must** place `cra_helper` above `django.contrib.staticfiles` in the list!

Additionally, add the following `STATICFILES_FINDERS` list to your `settings.py`:

```python
STATICFILES_FINDERS = [
    # Django defaults
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
    # A finder to pull in asset-manifest.json
    'cra_helper.finders.CRAManifestFinder',
]
```

You'll also need to specify the name of the folder containing your CRA files, relative to the base directory of the Django **project** (the folder containing `manage.py`). You can do so by setting `CRA_APP_NAME` in `settings.py`:

```python
CRA_APP_NAME = 'cra-app'
```

You can also optionally specify the port the CRA liveserver runs on in case, for example, it changes later or you eject your React app and decide to set it to run on a different port:

```python
CRA_PORT = 9999
```

> Note: if you don't set a value for `CRA_PORT` then **django-cra-helper** will default to port `3000`.

Once you've finished configuring everything **django-cra-helper** will make the following possible:

### Access React components in real-time from the CRA liveserver

If you run your CRA project's liveserver via `npm start` prior to starting your Django development server via `python manage.py runserver`, you can work on your React components as usual and see updated code instantly within Django.

When the CRA liveserver is running, **django-cra-helper** adds a `bundle_js` template variable that you can insert into your view's template to link to the liveserver's intermediate `bundle.js`. This file is recompiled on-the-fly by the liveserver whenever you edit your React code. Add it to your template as follows:

```html
  {% if bundle_js %}<script type="text/javascript" src="{{ bundle_js }}"></script>{% endif %}
```
> Note: Don't use the `static` template tag here! We need to get this file from the CRA liveserver instead

### Access React components in production

**django-cra-helper** also takes care of making sure that Django's `collectstatic` command pulls in production-ready bundles generated by CRA.

First, prepare your React files for production:

```sh
npm run build
```

This will output bundled, minified JavaScript and CSS, and assets to the `/build/` folder within your CRA app folder. You'll also see an `asset-manifest.json` file get pulled in. The contents of this CRA-generated file are used by **django-cra-helper** to help load React files even after CRA applies a unique hash to their filenames during the build process.

Once this command is complete, run the following Django command to gather your static files, including your React assets:

```sh
python manage.py collectstatic --no-input
```

Your React assets will be included within your other static assets placed within your `settings.STATIC_ROOT` directory to be served as usual in a Django production environment.

Similar to the `bundle_js` template variable mentioned earlier, **django-cra-helper** includes numerous other template variables when the CRA liveserver is _not_ running. The two most important ones are `main_js` and `main_css`. These can be injected into the page via a typical call to `{% static %}` in the template:

```html
{% if main_css %}<link href="{% static main_css %}" rel="stylesheet">{% endif %}
```
```html
{% if main_js %}<script type="text/javascript" src="{% static main_js %}"></script>{% endif %}

```

Other assets bundled by CRA, including image assets, can be accessed in templates by substituting `_` for `/` and `.` (period). **django-cra-helper** adds every entry in `asset-manifest.json` to the base context, using these substitution rules to accomodate Django's `static` tag.

For example, if there's a **logo.svg** file in your React project that you want to include in your Django template, you can include it as follows:

```html
<!-- This file is located at `/build/static/media/logo.svg` -->
<img src="{% static static_media_logo_svg %}" height="40" width="40">
```
> Note: This is optional! You are still free to place static assets in your Django app's `/static/` directory and load them as usual. The special substitution mentioned above is only needed if you wish to use React assets outside of your components.

## Accessing React Components via Django template contexts

Your React app will need a small bit of re-archiceture to prepare it to accept input values from Django when Django prepares to serve a view. The following is an example of how a couple of small tweaks to your CRA project's `src/index.js` file will create a simple API for Django to communicate with the bundled React codebase:

```js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import './index.css';

/**
 * Maintain a simple map of React components to make it easier
 * for Django to reference individual components
 */
const pages = {
  App,
}

/**
 * If Django hasn't injected these properties into the HTML
 * template that's loading this script then we're viewing it
 * via the create-react-app liveserver
 */
window.component = window.component || 'App';
window.props = window.props || { env: 'create-react-app' };
window.reactRoot = window.reactRoot || document.getElementById('root');

ReactDOM.render(
  React.createElement(pages[window.component], window.props),
  window.reactRoot,
);
```

Basically, the file is modified to read values set to `window.component`, `window.props`, and `window.reactRoot`. Each of these three "inputs" will allow Django to easily specify which component to initialize on a per-view basis:

* `window.component`: A **string** that points to a Component entry in `pages`
* `window.props`: An **Object** containing props to get passed into the Component
* `window.reactRoot`: an **instance** of `document.getElementById`

> Note: Settings these values is optional. The defaults specified in the template above enable components to render as expected when viewed from the CRA liveserver.

Now that the "API" is in place, Django Views can include values for these inputs via the context they pass to their template:

```python
def index(request):
    context = {
        'component': 'App',
        'props': {
            'env': 'Django',
        },
    }
    return render(request, 'index.html', context)
```

And here's the `index.html` template that will render the context:

```html
{% load static %}
{% load cra_helper_tags %}
<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    {% if main_css %}<link href="{% static main_css %}" rel="stylesheet">{% endif %}
    <title>Django + React Project</title>
  </head>

  <body>
    <div id="react">Loading...</div>

    <script>
      window.component = '{{ component }}';
      window.props = {{ props | json }};
      window.reactRoot = document.getElementById('react');
    </script>
    {% if bundle_js %}<script type="text/javascript" src="{{ bundle_js }}"></script>{% endif %}
    {% if main_js %}<script type="text/javascript" src="{% static main_js %}"></script>{% endif %}
  </body>

</html>
```
The context's `component` and `props` are bound as usual to `window.component` and `window.props` respectively.

Note the use of the `json` filter when setting `windows.props`! `{% load cra_helper_tags %}` provides this filter as a way to easily sanitize and convert a Python `dict` to a Javascript `Object`. The View context prepared above thus renders to the following typical Javascript Object:

```js
// This is what is returned in the rendered HTML
window.props = {"env": "Django"};
```
Finally, `window.reactRoot` specifies the container element that the React component should be rendered into. Setting a value for this is only required if the container's `id` is *not* **"root"** (the same ID assigned to the container `<div>` in the CRA project's `index.html`.)

## The Payoff Revealed

When all is said and done, your React code should now render and be viewable in both the CRA liveserver and when served via Django. Here's a slightly-modified App component displayed in Django (left) and CRA (right):

![Comparison Shot](./side_by_side.png)

## TODO

* Figure out how to get Django to auto-reload when the CRA liveserver reloads after code is updated.